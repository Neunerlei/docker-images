# The Automated Build System

To ensure our images are secure, up-to-date, and consistently built, we use a custom, automated release platform powered by Node.js and GitHub Actions. This document explains its architecture.

## Core Philosophy

The system is designed to be **declarative** and **centralized**. The logic for how to build any given image lives in our `.github/.release/` directory. The individual workflow files (e.g., `.github/workflows/php-nginx.yml`) are simple configuration files that just tell the central engine *what* to build.

## The Build Pipeline: A Three-Stage Process

The pipeline for each image consists of three main jobs:

### 1. `discover`

This is the "brains" of the operation. It's a Node.js script that orchestrates the entire release plan.

*   **Fetches Upstream Tags:** It connects to the Docker Hub API and performs a fully paginated fetch to get a complete list of all available tags for a given base image (e.g., `library/nginx`).
*   **Version Parsing & Filtering:** It parses this massive list, filtering for specific variants (like `alpine`) and using `semver` to understand which versions are valid and how they relate to each other.
*   **Matrix Generation:** Based on the configuration passed from the workflow file (e.g., "track the latest 4 minor versions"), it determines the final list of versions that need to be built.
*   **Cascading Source Selection:** For each version in the build list, it finds the most appropriate source directory to use. This is our "cascading fallback" logic. If building for `1.29.1`, the script will search for `src/nginx/1.29.1`, then `src/nginx/1.29`, then `src/nginx/1.28`, etc., until it finds a suitable base. This allows for effortless support of new patch and minor versions that have no breaking changes.
*   **Outputs a Plan:** The job's final output is a JSON object (the "build matrix") that tells the next job exactly what to build, where to find the source files, and how to tag the final image.

### 2. `build-and-attest`

This job is the "engine". It's a matrix job that runs in parallel for every entry generated by the `discover` job.

*   It uses the official `docker/build-push-action` to perform a multi-platform build (`linux/amd64`, `linux/arm64`).
*   It passes the `SOURCE_IMAGE` as a build argument to the `Dockerfile`, ensuring the final image is built on the correct, newly discovered base tag.
*   After pushing the image, it uses `actions/attest-build-provenance` to generate and push a SLSA-compliant build attestation, cryptographically linking the final image digest to the exact source code and build process that created it.

### 3. `publish-tag-list`

This is our user-facing documentation job. It runs after all builds are complete.

*   It gathers information from the `discover` job, including the full list of tags that now exist on Docker Hub and which ones are actively maintained.
*   It uses a series of HTML templates to generate a clean, readable, and user-friendly webpage listing all available, maintained, and deprecated tags.
*   It then deploys this HTML file to GitHub Pages, providing a central, always-up-to-date reference for our users.
